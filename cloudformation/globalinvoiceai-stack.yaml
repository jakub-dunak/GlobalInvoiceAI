AWSTemplateFormatVersion: '2010-09-09'
Description: |
  GlobalInvoiceAI Agent - Serverless AI-powered invoice validation and generation system
  Features multi-currency support, tax compliance, and automated PDF generation using
  Amazon Bedrock AgentCore with Strands framework.

Parameters:
  Environment:
    Type: String
    Default: dev
    AllowedValues:
      - dev
      - staging
      - prod
    Description: Environment name for resource naming

  # ExternalAPIKeysSecret parameter removed - using hardcoded values for demo

  CognitoDomainPrefix:
    Type: String
    Description: Unique domain prefix for Cognito hosted UI (auto-generated during deployment)

Resources:
  # ========================================
  # S3 BUCKETS
  # ========================================

  InvoiceUploadBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub '${AWS::StackName}-invoice-upload-${Environment}'
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      NotificationConfiguration:
        EventBridgeConfiguration:
          EventBridgeEnabled: true
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Application
          Value: GlobalInvoiceAI

  ProcessedInvoicesBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub '${AWS::StackName}-processed-invoices-${Environment}'
      AccessControl: Private
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      LifecycleConfiguration:
        Rules:
          - Id: DeleteOldInvoices
            Status: Enabled
            ExpirationInDays: 90
            NoncurrentVersionExpiration:
              NoncurrentDays: 30
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Application
          Value: GlobalInvoiceAI

  AgentCodeBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub '${AWS::StackName}-agent-code-${Environment}'
      AccessControl: Private
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Application
          Value: GlobalInvoiceAI

  AmplifySourceBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub '${AWS::StackName}-amplify-source-${Environment}'
      AccessControl: Private
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Application
          Value: GlobalInvoiceAI

  # ========================================
  # DYNAMODB TABLES
  # ========================================

  InvoicesTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub '${AWS::StackName}-Invoices-${Environment}'
      AttributeDefinitions:
        - AttributeName: InvoiceId
          AttributeType: S
        - AttributeName: Status
          AttributeType: S
        - AttributeName: CreatedAt
          AttributeType: S
        - AttributeName: CustomerId
          AttributeType: S
      KeySchema:
        - AttributeName: InvoiceId
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: StatusIndex
          KeySchema:
            - AttributeName: Status
              KeyType: HASH
            - AttributeName: CreatedAt
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
        - IndexName: CustomerIndex
          KeySchema:
            - AttributeName: CustomerId
              KeyType: HASH
            - AttributeName: CreatedAt
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      BillingMode: PAY_PER_REQUEST
      PointInTimeRecoverySpecification:
        PointInTimeRecoveryEnabled: true
      SSESpecification:
        SSEEnabled: true
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Application
          Value: GlobalInvoiceAI

  TaxRatesCache:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub '${AWS::StackName}-TaxRates-${Environment}'
      AttributeDefinitions:
        - AttributeName: CountryRegion
          AttributeType: S
        - AttributeName: TaxType
          AttributeType: S
      KeySchema:
        - AttributeName: CountryRegion
          KeyType: HASH
        - AttributeName: TaxType
          KeyType: RANGE
      BillingMode: PAY_PER_REQUEST
      TimeToLiveSpecification:
        AttributeName: TTL
        Enabled: true
      SSESpecification:
        SSEEnabled: true
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Application
          Value: GlobalInvoiceAI

  ProcessingLogsTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: !Sub '${AWS::StackName}-ProcessingLogs-${Environment}'
      AttributeDefinitions:
        - AttributeName: LogId
          AttributeType: S
        - AttributeName: Timestamp
          AttributeType: S
        - AttributeName: InvoiceId
          AttributeType: S
      KeySchema:
        - AttributeName: LogId
          KeyType: HASH
      GlobalSecondaryIndexes:
        - IndexName: InvoiceTimestampIndex
          KeySchema:
            - AttributeName: InvoiceId
              KeyType: HASH
            - AttributeName: Timestamp
              KeyType: RANGE
          Projection:
            ProjectionType: ALL
      BillingMode: PAY_PER_REQUEST
      TimeToLiveSpecification:
        AttributeName: TTL
        Enabled: true
      SSESpecification:
        SSEEnabled: true
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Application
          Value: GlobalInvoiceAI

  # ========================================
  # ECR REPOSITORY FOR AGENTCORE
  # ========================================

  GlobalInvoiceAIAgentRepo:
    Type: AWS::ECR::Repository
    Properties:
      RepositoryName: !Sub '${AWS::StackName}-agent-${Environment}'
      ImageTagMutability: MUTABLE
      ImageScanningConfiguration:
        ScanOnPush: true
      EncryptionConfiguration:
        EncryptionType: AES256
      LifecyclePolicy:
        LifecyclePolicyText: |
          {
            "rules": [
              {
                "rulePriority": 1,
                "description": "Keep last 5 images",
                "selection": {
                  "tagStatus": "any",
                  "countType": "imageCountMoreThan",
                  "countNumber": 5
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Application
          Value: GlobalInvoiceAI

  # ========================================
  # SECRETS MANAGER (REMOVED - USING HARDCODED VALUES)
  # ========================================
  # External API keys are no longer needed as we use hardcoded values for demo
  # In production, you would restore this for real-time API integration

  # ========================================
  # IAM ROLES
  # ========================================

  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${AWS::StackName}-lambda-execution-${Environment}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:ListBucket
                Resource:
                  - !GetAtt InvoiceUploadBucket.Arn
                  - !Sub '${InvoiceUploadBucket.Arn}/*'
                  - !GetAtt ProcessedInvoicesBucket.Arn
                  - !Sub '${ProcessedInvoicesBucket.Arn}/*'
                  - !GetAtt AgentCodeBucket.Arn
                  - !Sub '${AgentCodeBucket.Arn}/*'
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:Query
                  - dynamodb:Scan
                  - dynamodb:UpdateItem
                Resource:
                  - !GetAtt InvoicesTable.Arn
                  - !GetAtt TaxRatesCache.Arn
                  - !GetAtt ProcessingLogsTable.Arn
                  - !Sub '${InvoicesTable.Arn}/index/*'
                  - !Sub '${TaxRatesCache.Arn}/index/*'
                  - !Sub '${ProcessingLogsTable.Arn}/index/*'
        # SecretsManager access removed - using hardcoded values for demo
        - PolicyName: AgentCoreAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock-agentcore:InvokeAgentRuntime
                Resource: '*'
        - PolicyName: BedrockModelAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                Resource: '*'
        - PolicyName: CloudWatchMetrics
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - cloudwatch:PutMetricData
                Resource: '*'
        - PolicyName: ParameterStoreAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ssm:GetParameter
                  - ssm:PutParameter
                Resource: !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/globalinvoiceai/*'

  AgentCoreExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${AWS::StackName}-agentcore-execution-${Environment}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: BedrockAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:InvokeModelWithResponseStream
                Resource: '*'
        - PolicyName: AgentCoreRuntimeAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock-agentcore:InvokeAgentRuntime
                Resource: '*'
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:Query
                  - dynamodb:Scan
                  - dynamodb:UpdateItem
                Resource:
                  - !GetAtt InvoicesTable.Arn
                  - !GetAtt TaxRatesCache.Arn
                  - !GetAtt ProcessingLogsTable.Arn
                  - !Sub '${InvoicesTable.Arn}/index/*'
                  - !Sub '${TaxRatesCache.Arn}/index/*'
                  - !Sub '${ProcessingLogsTable.Arn}/index/*'
        # SecretsManager access removed - using hardcoded values for demo
        - PolicyName: CloudWatchLogs
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:CreateLogGroup
                  - logs:PutLogEvents
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/*:*'

  CustomResourceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${AWS::StackName}-custom-resource-${Environment}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: AgentCoreManagement
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock-agentcore:CreateAgentRuntime
                  - bedrock-agentcore:UpdateAgentRuntime
                  - bedrock-agentcore:DeleteAgentRuntime
                  - bedrock-agentcore:GetAgentRuntime
                  - bedrock-agentcore:ListAgentRuntimes
                Resource: '*'
        - PolicyName: ECRPush
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ecr:GetAuthorizationToken
                  - ecr:InitiateLayerUpload
                  - ecr:UploadLayerPart
                  - ecr:CompleteLayerUpload
                  - ecr:PutImage
                Resource: !GetAtt GlobalInvoiceAIAgentRepo.Arn
        - PolicyName: ParameterStoreWrite
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ssm:PutParameter
                Resource: !Sub 'arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/globalinvoiceai/*'

  # ========================================
  # LAMBDA FUNCTIONS
  # ========================================

  InvoiceTriggerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-invoice-trigger-${Environment}'
      Runtime: python3.11
      Role: !GetAtt LambdaExecutionRole.Arn
      Handler: index.handler
      Timeout: 300
      MemorySize: 256
      Environment:
        Variables:
          INVOICES_TABLE: !Ref InvoicesTable
          TAX_RATES_TABLE: !Ref TaxRatesCache
          LOGS_TABLE: !Ref ProcessingLogsTable
          PROCESSED_BUCKET: !Ref ProcessedInvoicesBucket
          AGENTCORE_RUNTIME_PARAM: !Sub '/globalinvoiceai/agentcore/runtime-arn'
          ENVIRONMENT: !Ref Environment
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import uuid
          from datetime import datetime
          import base64

          s3_client = boto3.client('s3')
          dynamodb = boto3.resource('dynamodb')
          cloudwatch = boto3.client('cloudwatch')
          ssm = boto3.client('ssm')

          def handler(event, context):
              """Process S3 upload events and trigger AgentCore Runtime"""
              try:
                  # Parse S3 event
                  for record in event['Records']:
                      bucket_name = record['s3']['bucket']['name']
                      object_key = record['s3']['object']['key']

                      print(f"Processing invoice: s3://{bucket_name}/{object_key}")

                      # Read invoice file from S3
                      response = s3_client.get_object(Bucket=bucket_name, Key=object_key)
                      invoice_content = response['Body'].read().decode('utf-8')

                      try:
                          invoice_data = json.loads(invoice_content)
                      except json.JSONDecodeError:
                          # Try CSV format (simplified parsing)
                          import csv
                          import io
                          csv_reader = csv.DictReader(io.StringIO(invoice_content))
                          invoice_data = next(csv_reader)

                      # Generate invoice ID
                      invoice_id = str(uuid.uuid4())

                      # Store initial record in DynamoDB
                      invoices_table = dynamodb.Table(os.environ['INVOICES_TABLE'])
                      invoices_table.put_item(Item={
                          'InvoiceId': invoice_id,
                          'Status': 'PROCESSING',
                          'OriginalFileKey': object_key,
                          'InvoiceData': invoice_data,
                          'CreatedAt': datetime.utcnow().isoformat(),
                          'UpdatedAt': datetime.utcnow().isoformat()
                      })

                      # Get AgentCore Runtime ARN from Parameter Store
                      try:
                          runtime_param = ssm.get_parameter(
                              Name=os.environ['AGENTCORE_RUNTIME_PARAM']
                          )
                          runtime_arn = runtime_param['Parameter']['Value']
                      except ssm.exceptions.ParameterNotFound:
                          print("AgentCore Runtime not deployed yet")
                          return {"statusCode": 500, "body": "AgentCore Runtime not available"}

                      # Invoke AgentCore Runtime
                      agentcore = boto3.client('bedrock-agentcore-runtime')
                      response = agentcore.invoke_agent(
                          agentArn=runtime_arn,
                          runtimeEndpoint='DEFAULT',
                          prompt={
                              "invoice_data": invoice_data,
                              "operation": "validate",
                              "invoice_id": invoice_id
                          }
                      )

                      # Process streaming response
                      full_response = ""
                      for event in response.get('completion', []):
                          if 'chunk' in event:
                              full_response += event['chunk']['bytes'].decode('utf-8')

                      # Parse and store result
                      result = json.loads(full_response)
                      invoices_table.update_item(
                          Key={'InvoiceId': invoice_id},
                          UpdateExpression='SET #status = :status, ValidationResult = :result, UpdatedAt = :updated',
                          ExpressionAttributeNames={'#status': 'Status'},
                          ExpressionAttributeValues={
                              ':status': result.get('status', 'ERROR'),
                              ':result': result,
                              ':updated': datetime.utcnow().isoformat()
                          }
                      )

                      # Send CloudWatch metrics
                      cloudwatch.put_metric_data(
                          Namespace='GlobalInvoiceAI',
                          MetricData=[
                              {
                                  'MetricName': 'InvoiceProcessed',
                                  'Value': 1,
                                  'Unit': 'Count',
                                  'Dimensions': [
                                      {'Name': 'Environment', 'Value': os.environ['ENVIRONMENT']}
                                  ]
                              },
                              {
                                  'MetricName': 'ProcessingTime',
                                  'Value': (datetime.utcnow() - datetime.fromisoformat(
                                      invoices_table.get_item(Key={'InvoiceId': invoice_id})['Item']['CreatedAt']
                                  )).total_seconds(),
                                  'Unit': 'Seconds',
                                  'Dimensions': [
                                      {'Name': 'Environment', 'Value': os.environ['ENVIRONMENT']}
                                  ]
                              }
                          ]
                      )

                      print(f"Successfully processed invoice {invoice_id}")

              except Exception as e:
                  print(f"Error processing invoice: {str(e)}")
                  # Log error to DynamoDB
                  logs_table = dynamodb.Table(os.environ['LOGS_TABLE'])
                  logs_table.put_item(Item={
                      'LogId': str(uuid.uuid4()),
                      'Timestamp': datetime.utcnow().isoformat(),
                      'Level': 'ERROR',
                      'Message': str(e),
                      'Source': 'InvoiceTriggerFunction'
                  })

                  # Send error metric
                  cloudwatch.put_metric_data(
                      Namespace='GlobalInvoiceAI',
                      MetricData=[{
                          'MetricName': 'ProcessingError',
                          'Value': 1,
                          'Unit': 'Count'
                      }]
                  )

                  raise e

              return {"statusCode": 200, "body": "Processing complete"}
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Application
          Value: GlobalInvoiceAI

  PDFGeneratorFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-pdf-generator-${Environment}'
      Runtime: python3.11
      Role: !GetAtt LambdaExecutionRole.Arn
      Handler: index.handler
      Timeout: 60
      MemorySize: 512
      Environment:
        Variables:
          INVOICES_TABLE: !Ref InvoicesTable
          PROCESSED_BUCKET: !Ref ProcessedInvoicesBucket
          ENVIRONMENT: !Ref Environment
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from datetime import datetime
          from reportlab.lib.pagesizes import letter, A4
          from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
          from reportlab.lib.styles import getSampleStyleSheet
          from reportlab.lib import colors
          import io

          s3_client = boto3.client('s3')
          dynamodb = boto3.resource('dynamodb')

          def handler(event, context):
              """Generate PDF invoice from validated invoice data"""
              try:
                  invoice_id = event['invoiceId']

                  # Get invoice data from DynamoDB
                  invoices_table = dynamodb.Table(os.environ['INVOICES_TABLE'])
                  response = invoices_table.get_item(Key={'InvoiceId': invoice_id})

                  if 'Item' not in response:
                      return {"statusCode": 404, "body": "Invoice not found"}

                  invoice = response['Item']
                  if invoice['Status'] != 'VALIDATED':
                      return {"statusCode": 400, "body": "Invoice not validated"}

                  # Generate PDF
                  pdf_buffer = io.BytesIO()
                  doc = SimpleDocTemplate(pdf_buffer, pagesize=A4)
                  styles = getSampleStyleSheet()
                  story = []

                  # Title
                  title = Paragraph(f"INVOICE #{invoice_id}", styles['Title'])
                  story.append(title)
                  story.append(Spacer(1, 12))

                  # Invoice details table
                  invoice_data = invoice.get('InvoiceData', {})
                  details_data = [
                      ['Invoice Number', invoice_id],
                      ['Date', datetime.utcnow().strftime('%Y-%m-%d')],
                      ['Customer', invoice_data.get('customer_name', 'N/A')],
                      ['Total Amount', f"${invoice_data.get('total_amount', 0):.2f}"],
                      ['Tax Amount', f"${invoice_data.get('tax_amount', 0):.2f}"],
                      ['Currency', invoice_data.get('currency', 'USD')]
                  ]

                  details_table = Table(details_data, colWidths=[100, 300])
                  details_table.setStyle(TableStyle([
                      ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                      ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                      ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                      ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                      ('FONTSIZE', (0, 0), (-1, 0), 12),
                      ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                      ('BACKGROUND', (0, 1), (-1, -1), colors.beige),
                      ('GRID', (0, 0), (-1, -1), 1, colors.black)
                  ]))

                  story.append(details_table)
                  story.append(Spacer(1, 20))

                  # Line items (if available)
                  if 'line_items' in invoice_data:
                      items_title = Paragraph("Line Items", styles['Heading2'])
                      story.append(items_title)
                      story.append(Spacer(1, 12))

                      items_data = [['Description', 'Quantity', 'Unit Price', 'Total']]
                      for item in invoice_data['line_items']:
                          items_data.append([
                              item.get('description', ''),
                              str(item.get('quantity', 0)),
                              f"${item.get('unit_price', 0):.2f}",
                              f"${item.get('total', 0):.2f}"
                          ])

                      items_table = Table(items_data, colWidths=[200, 60, 80, 80])
                      items_table.setStyle(TableStyle([
                          ('BACKGROUND', (0, 0), (-1, 0), colors.grey),
                          ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                          ('ALIGN', (0, 0), (-1, -1), 'CENTER'),
                          ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                          ('FONTSIZE', (0, 0), (-1, 0), 12),
                          ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                          ('BACKGROUND', (0, 1), (-1, -1), colors.white),
                          ('GRID', (0, 0), (-1, -1), 1, colors.black)
                      ]))

                      story.append(items_table)

                  # Build PDF
                  doc.build(story)

                  # Upload PDF to S3
                  pdf_key = f"invoice-{invoice_id}.pdf"
                  pdf_buffer.seek(0)
                  s3_client.put_object(
                      Bucket=os.environ['PROCESSED_BUCKET'],
                      Key=pdf_key,
                      Body=pdf_buffer.getvalue(),
                      ContentType='application/pdf',
                      Metadata={
                          'invoice-id': invoice_id,
                          'generated-at': datetime.utcnow().isoformat()
                      }
                  )

                  # Update invoice record with PDF location
                  invoices_table.update_item(
                      Key={'InvoiceId': invoice_id},
                      UpdateExpression='SET PDFLocation = :pdf',
                      ExpressionAttributeValues={':pdf': pdf_key}
                  )

                  return {
                      "statusCode": 200,
                      "body": json.dumps({
                          "invoiceId": invoice_id,
                          "pdfLocation": pdf_key,
                          "bucket": os.environ['PROCESSED_BUCKET']
                      })
                  }

              except Exception as e:
                  print(f"Error generating PDF: {str(e)}")
                  raise e
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Application
          Value: GlobalInvoiceAI

  AgentCoreDeployFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${AWS::StackName}-agentcore-deploy-${Environment}'
      Runtime: python3.11
      Role: !GetAtt CustomResourceRole.Arn
      Handler: index.handler
      Timeout: 900  # 15 minutes for deployment
      MemorySize: 512
      Environment:
        Variables:
          ECR_REPO: !Ref GlobalInvoiceAIAgentRepo
          AGENT_NAME: !Sub 'GlobalInvoiceAI-${Environment}'
          RUNTIME_PARAM: !Sub '/globalinvoiceai/agentcore/runtime-arn'
          ENVIRONMENT: !Ref Environment
          AGENTCORE_EXECUTION_ROLE_ARN: !GetAtt AgentCoreExecutionRole.Arn
          TAX_RATES_TABLE: !Ref TaxRatesCache
          INVOICES_TABLE: !Ref InvoicesTable
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import zipfile
          import tempfile
          import subprocess
          from datetime import datetime

          ecr_client = boto3.client('ecr')
          bedrock_agentcore = boto3.client('bedrock-agentcore')
          ssm = boto3.client('ssm')

          def handler(event, context):
              """Custom resource to deploy AgentCore application"""
              try:
                  request_type = event['RequestType']

                  if request_type == 'Create':
                      return create_agentcore_app()
                  elif request_type == 'Update':
                      return update_agentcore_app()
                  elif request_type == 'Delete':
                      return delete_agentcore_app()

              except Exception as e:
                  print(f"Error in AgentCore deployment: {str(e)}")
                  raise e

          def create_agentcore_app():
              """Create and deploy the AgentCore application"""
              agent_name = os.environ['AGENT_NAME']
              repo_name = os.environ['ECR_REPO']

              # Get ECR login token
              auth_token = ecr_client.get_authorization_token()
              username, password = base64.b64decode(auth_token['authorizationData'][0]['authorizationToken']).decode().split(':')

              # Build and push container image
              with tempfile.TemporaryDirectory() as temp_dir:
                  # Create Dockerfile
                  dockerfile_content = '''
                  FROM public.ecr.aws/lambda/python:3.11

                  COPY invoice_agent.py requirements.txt ./

                  RUN pip install -r requirements.txt

                  CMD ["invoice_agent.app"]
                  '''

                  with open(f'{temp_dir}/Dockerfile', 'w') as f:
                      f.write(dockerfile_content)

                  # Create requirements.txt
                  requirements_content = '''
                  bedrock-agentcore-sdk-python==1.0.0
                  strands-agents==1.0.0
                  boto3==1.34.0
                  requests==2.31.0
                  '''

                  with open(f'{temp_dir}/requirements.txt', 'w') as f:
                      f.write(requirements_content)

                  # Create agent code
                  agent_code = '''
                  from strands import Agent, tool
                  from strands.models import BedrockModel
                  from bedrock_agentcore.runtime import BedrockAgentCoreApp
                  import boto3

                  app = BedrockAgentCoreApp()

                  # Initialize AWS clients
                  dynamodb = boto3.resource('dynamodb')
                  # Removed secrets manager client - using hardcoded values
                  s3 = boto3.client('s3')

                  @tool
                  def get_tax_rate(country: str, region: str, tax_type: str) -> dict:
                      """Get tax rate for country/region from cache or API"""
                      # Check DynamoDB cache first
                      tax_table = dynamodb.Table(os.environ.get('TAX_RATES_TABLE', 'globalinvoiceai-TaxRates-dev'))

                      try:
                          response = tax_table.get_item(Key={'CountryRegion': f"{country}-{region}", 'TaxType': tax_type})
                          if 'Item' in response:
                              return {
                                  "rate": float(response['Item']['Rate']),
                                  "source": "cache",
                                  "last_updated": response['Item']['UpdatedAt']
                              }
                      except Exception as e:
                          print(f"Cache lookup failed: {e}")

                      # Call external API
                      try:
                          secret_name = os.environ.get('API_KEYS_SECRET', 'globalinvoiceai-external-api-keys-dev')
                          secrets_response = secrets.get_secret_value(SecretId=secret_name)
                          api_keys = json.loads(secrets_response['SecretString'])

                          # Use abstractAPI for tax rates (placeholder - replace with actual API)
                          # For demo, return hardcoded rates
                          tax_rates = {
                              "US-CA": {"VAT": 0.0875, "SALES_TAX": 0.0875},
                              "US-NY": {"VAT": 0.08, "SALES_TAX": 0.08},
                              "UK": {"VAT": 0.20},
                              "IN": {"GST": 0.18}
                          }

                          if f"{country}-{region}" in tax_rates and tax_type in tax_rates[f"{country}-{region}"]:
                              rate = tax_rates[f"{country}-{region}"][tax_type]

                              # Cache the result
                              tax_table.put_item(Item={
                                  'CountryRegion': f"{country}-{region}",
                                  'TaxType': tax_type,
                                  'Rate': rate,
                                  'UpdatedAt': datetime.utcnow().isoformat(),
                                  'TTL': int(datetime.utcnow().timestamp()) + 86400  # 24 hours
                              })

                              return {"rate": rate, "source": "api", "last_updated": datetime.utcnow().isoformat()}
                      except Exception as e:
                          print(f"API call failed: {e}")

                      # Fallback to hardcoded rates
                      fallback_rates = {"US": 0.07, "UK": 0.20, "IN": 0.18}
                      rate = fallback_rates.get(country, 0.0)

                      return {"rate": rate, "source": "fallback", "last_updated": datetime.utcnow().isoformat()}

                  @tool
                  def convert_currency(amount: float, from_currency: str, to_currency: str) -> dict:
                      """Convert currency using hardcoded exchange rates"""
                      # Hardcoded exchange rates for demo purposes
                      # In production, these would come from real-time APIs like Fixer.io
                      exchange_rates = {
                          # Base rates (relative to USD)
                          "USD": 1.0,
                          "EUR": 0.85,     # 1 USD = 0.85 EUR
                          "GBP": 0.73,     # 1 USD = 0.73 GBP
                          "INR": 83.0,     # 1 USD = 83 INR
                          "CAD": 1.35,     # 1 USD = 1.35 CAD
                          "AUD": 1.52,     # 1 USD = 1.52 AUD
                          "JPY": 150.0,    # 1 USD = 150 JPY
                          "CHF": 0.92,     # 1 USD = 0.92 CHF
                          "CNY": 7.25,     # 1 USD = 7.25 CNY
                          "BRL": 5.2,      # 1 USD = 5.2 BRL
                      }

                      try:
                          # Get exchange rates
                          from_rate = exchange_rates.get(from_currency.upper(), 1.0)
                          to_rate = exchange_rates.get(to_currency.upper(), 1.0)

                          if from_rate == 1.0 and from_currency.upper() not in exchange_rates:
                              return {"error": f"Unsupported currency: {from_currency}"}

                          if to_rate == 1.0 and to_currency.upper() not in exchange_rates:
                              return {"error": f"Unsupported currency: {to_currency}"}

                          # Calculate conversion
                          exchange_rate = to_rate / from_rate
                          converted_amount = amount * exchange_rate

                          return {
                              "original_amount": amount,
                              "converted_amount": round(converted_amount, 2),
                              "exchange_rate": round(exchange_rate, 4),
                              "from_currency": from_currency.upper(),
                              "to_currency": to_currency.upper(),
                              "timestamp": datetime.utcnow().isoformat(),
                              "source": "hardcoded"
                          }

                      except Exception as e:
                          return {"error": f"Currency conversion failed: {str(e)}"}

                  @tool
                  def validate_invoice_fields(invoice_data: dict) -> dict:
                      """Validate invoice has required fields"""
                      required_fields = ['customer_name', 'total_amount', 'currency']
                      missing_fields = []

                      for field in required_fields:
                          if field not in invoice_data or not invoice_data[field]:
                              missing_fields.append(field)

                      errors = []
                      warnings = []

                      if missing_fields:
                          errors.append(f"Missing required fields: {', '.join(missing_fields)}")

                      # Validate amounts
                      if 'total_amount' in invoice_data:
                          try:
                              amount = float(invoice_data['total_amount'])
                              if amount <= 0:
                                  errors.append("Total amount must be positive")
                              elif amount > 1000000:
                                  warnings.append("Very large amount - please verify")
                          except (ValueError, TypeError):
                              errors.append("Invalid total amount format")

                      # Validate currency
                      if 'currency' in invoice_data:
                          valid_currencies = ['USD', 'EUR', 'GBP', 'INR', 'CAD', 'AUD']
                          if invoice_data['currency'] not in valid_currencies:
                              warnings.append(f"Currency {invoice_data['currency']} not in standard list")

                      return {
                          "valid": len(errors) == 0,
                          "errors": errors,
                          "warnings": warnings
                      }

                  @tool
                  def detect_discrepancies(invoice: dict, expected_values: dict) -> dict:
                      """Detect pricing/quantity discrepancies"""
                      discrepancies = []

                      # Compare total amount
                      if 'total_amount' in expected_values:
                          expected_amount = float(expected_values['total_amount'])
                          actual_amount = float(invoice.get('total_amount', 0))

                          if abs(actual_amount - expected_amount) / expected_amount > 0.05:  # 5% tolerance
                              discrepancies.append({
                                  "field": "total_amount",
                                  "expected": expected_amount,
                                  "actual": actual_amount,
                                  "difference": actual_amount - expected_amount,
                                  "percentage": abs(actual_amount - expected_amount) / expected_amount * 100
                              })

                      # Compare line items if available
                      if 'line_items' in expected_values and 'line_items' in invoice:
                          for i, (expected_item, actual_item) in enumerate(
                              zip(expected_values['line_items'], invoice['line_items'])
                          ):
                              if expected_item.get('unit_price') != actual_item.get('unit_price'):
                                  discrepancies.append({
                                      "field": f"line_items[{i}].unit_price",
                                      "expected": expected_item.get('unit_price'),
                                      "actual": actual_item.get('unit_price')
                                  })

                      return {
                          "has_discrepancies": len(discrepancies) > 0,
                          "discrepancies": discrepancies,
                          "severity": "high" if len(discrepancies) > 0 else "none"
                      }

                  @tool
                  def store_invoice_result(invoice_id: str, validation_result: dict) -> dict:
                      """Store validated invoice in DynamoDB"""
                      invoices_table = dynamodb.Table(os.environ.get('INVOICES_TABLE', 'globalinvoiceai-Invoices-dev'))

                      try:
                          invoices_table.update_item(
                              Key={'InvoiceId': invoice_id},
                              UpdateExpression='SET ValidationResult = :result, UpdatedAt = :updated',
                              ExpressionAttributeValues={
                                  ':result': validation_result,
                                  ':updated': datetime.utcnow().isoformat()
                              }
                          )
                          return {"success": True, "invoice_id": invoice_id}
                      except Exception as e:
                          return {"success": False, "error": str(e)}

                  # Initialize Bedrock model
                  model = BedrockModel(
                      model_id="us.anthropic.claude-3-5-sonnet-20241022-v1:0"
                  )

                  # Create agent with tools
                  agent = Agent(
                      model=model,
                      system_prompt="""You are an expert invoice validation and generation agent for GlobalInvoiceAI.

                  Your responsibilities:
                  1. Validate incoming vendor invoices for pricing discrepancies, missing fields, and compliance
                  2. Calculate correct taxes based on country/region (US state sales tax, UK VAT 20%, India GST 18%)
                  3. Convert currencies using real-time exchange rates
                  4. Generate compliant outgoing customer invoices
                  5. Flag any errors or anomalies for human review

                  Always use available tools to lookup tax rates, convert currencies, and validate data.
                  Store all results for audit compliance.""",
                      tools=[get_tax_rate, convert_currency, validate_invoice_fields,
                             detect_discrepancies, store_invoice_result]
                  )

                  @app.entrypoint
                  async def process_invoice(payload, context):
                      """Main entrypoint for invoice processing with streaming"""
                      invoice_data = payload.get("invoice_data")
                      operation = payload.get("operation", "validate")
                      invoice_id = payload.get("invoice_id")

                      if operation == "validate":
                          prompt = f"""Validate this vendor invoice for compliance and accuracy:
                          {json.dumps(invoice_data, indent=2)}

                          Check: required fields, tax calculations, pricing, currency."""
                      else:
                          prompt = f"""Generate a compliant customer invoice based on this sale data:
                          {json.dumps(invoice_data, indent=2)}

                          Calculate correct taxes, apply currency conversion if needed."""

                      try:
                          # Stream response
                          full_response = ""
                          async for event in agent.stream_async(prompt):
                              if "data" in event:
                                  full_response += event["data"]
                                  yield event["data"]

                          # Parse final result and store
                          result = json.loads(full_response)

                          # Store result in DynamoDB
                          store_result = store_invoice_result(invoice_id, result)
                          if not store_result["success"]:
                              yield {"error": f"Failed to store result: {store_result['error']}"}

                          return {"status": "success", "response": full_response}

                      except Exception as e:
                          yield {"error": str(e)}

                  if __name__ == "__main__":
                      app.run()
                  '''

                  with open(f'{temp_dir}/invoice_agent.py', 'w') as f:
                      f.write(agent_code)

                  # Build and push Docker image
                  repo_uri = auth_token['authorizationData'][0]['proxyEndpoint']
                  image_tag = f"{repo_uri}/{repo_name}:latest"

                  # Login to ECR
                  subprocess.run(['docker', 'login', '--username', username, '--password', password, repo_uri],
                               check=True, capture_output=True)

                  # Build image
                  subprocess.run(['docker', 'build', '-t', image_tag, temp_dir],
                               check=True, capture_output=True)

                  # Push image
                  subprocess.run(['docker', 'push', image_tag],
                               check=True, capture_output=True)

                  # Create AgentCore Agent
                  agent_response = bedrock_agentcore.create_agent(
                      agentName=agent_name,
                      description='GlobalInvoiceAI Agent for invoice validation and generation',
                      agentResourceRoleArn='${AGENTCORE_EXECUTION_ROLE_ARN}',
                      tags=[
                          {'key': 'Environment', 'value': '${ENVIRONMENT}'},
                          {'key': 'Application', 'value': 'GlobalInvoiceAI'}
                      ]
                  )

                  agent_id = agent_response['agent']['agentId']
                  print(f"Created AgentCore Agent: {agent_id}")

                  # Create AgentCore Runtime
                  runtime_response = bedrock_agentcore.create_agent_runtime(
                      agentId=agent_id,
                      runtimeConfiguration={
                          'type': 'container',
                          'containerRuntimeConfiguration': {
                              'containerImageUri': image_tag
                          }
                      }
                  )

                  runtime_arn = runtime_response['agentRuntime']['agentRuntimeArn']
                  print(f"Created AgentCore Runtime: {runtime_arn}")

                  # Store runtime ARN in Parameter Store
                  ssm.put_parameter(
                      Name=os.environ['RUNTIME_PARAM'],
                      Value=runtime_arn,
                      Type='String',
                      Description='AgentCore Runtime ARN for GlobalInvoiceAI'
                  )

                  return {
                      'Status': 'SUCCESS',
                      'PhysicalResourceId': agent_id,
                      'Data': {
                          'AgentId': agent_id,
                          'RuntimeArn': runtime_arn
                      }
                  }

              except Exception as e:
                  print(f"Error creating AgentCore app: {str(e)}")
                  return {'Status': 'FAILED', 'Reason': str(e)}

          def update_agentcore_app():
              """Update existing AgentCore application"""
              # Similar to create but for updates
              return {'Status': 'SUCCESS'}

          def delete_agentcore_app():
              """Delete AgentCore application"""
              # Cleanup resources
              return {'Status': 'SUCCESS'}
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Application
          Value: GlobalInvoiceAI

  # ========================================
  # EVENTBRIDGE RULE FOR S3 TRIGGERS
  # ========================================

  InvoiceUploadEventRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub '${AWS::StackName}-invoice-upload-${Environment}'
      Description: Trigger Lambda when invoices are uploaded to S3
      State: ENABLED
      EventPattern:
        source:
          - aws.s3
        detail-type:
          - Object Created
        detail:
          bucket:
            name:
              - !Ref InvoiceUploadBucket
          object:
            key:
              - prefix: ""
      Targets:
        - Id: InvoiceTriggerFunction
          Arn: !GetAtt InvoiceTriggerFunction.Arn

  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref InvoiceTriggerFunction
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt InvoiceUploadEventRule.Arn

  # ========================================
  # COGNITO USER POOL
  # ========================================

  UserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: !Sub '${AWS::StackName}-users-${Environment}'
      Policies:
        PasswordPolicy:
          MinimumLength: 8
          RequireUppercase: true
          RequireLowercase: true
          RequireNumbers: true
          RequireSymbols: false
      UsernameAttributes:
        - email
      Schema:
        - Name: email
          AttributeDataType: String
          Required: true
          Mutable: true
        - Name: given_name
          AttributeDataType: String
          Required: false
          Mutable: true
        - Name: family_name
          AttributeDataType: String
          Required: false
          Mutable: true

  UserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      UserPoolId: !Ref UserPool
      ClientName: !Sub '${AWS::StackName}-client-${Environment}'
      GenerateSecret: false
      RefreshTokenValidity: 30
      AccessTokenValidity: 60
      IdTokenValidity: 60
      TokenValidityUnits:
        AccessToken: minutes
        IdToken: minutes
        RefreshToken: days
      PreventUserExistenceErrors: ENABLED
      ExplicitAuthFlows:
        - ALLOW_USER_PASSWORD_AUTH
        - ALLOW_REFRESH_TOKEN_AUTH
        - ALLOW_ADMIN_USER_PASSWORD_AUTH
      SupportedIdentityProviders:
        - COGNITO
      # CallbackURLs will be configured after Amplify deployment
      # Use placeholder that will be updated post-deployment
      AllowedOAuthFlows:
        - code
        - implicit
      AllowedOAuthScopes:
        - email
        - openid
        - profile

  UserPoolDomain:
    Type: AWS::Cognito::UserPoolDomain
    Properties:
      UserPoolId: !Ref UserPool
      Domain: !Sub '${CognitoDomainPrefix}-${Environment}-${AWS::AccountId}'

  # ========================================
  # API GATEWAY
  # ========================================

  RestApi:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub '${AWS::StackName}-api-${Environment}'
      Description: API Gateway for GlobalInvoiceAI
      EndpointConfiguration:
        Types:
          - REGIONAL
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Application
          Value: GlobalInvoiceAI

  ApiGatewayRootMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref RestApi
      ResourceId: !GetAtt RestApi.RootResourceId
      HttpMethod: ANY
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        RequestTemplates:
          application/json: '{"statusCode": 200}'

  ApiGatewayDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - ApiGatewayRootMethod
    Properties:
      RestApiId: !Ref RestApi
      StageName: !Ref Environment

  # ========================================
  # AMPLIFY APP
  # ========================================

  AmplifyApp:
    Type: AWS::Amplify::App
    Properties:
      Name: !Sub '${AWS::StackName}-ui-${Environment}'
      Repository: 'https://github.com/YOUR_USERNAME/GlobalInvoiceAI'  # Replace with actual repo
      AccessToken: 'YOUR_GITHUB_TOKEN'  # Replace with actual token or use OAuth
      BuildSpec: |
        version: 1
        frontend:
          phases:
            preBuild:
              commands:
                - npm ci
            build:
              commands:
                - npm run build
          artifacts:
            baseDirectory: build
            files:
              - '**/*'
          cache:
            paths:
              - node_modules/**/*
      EnvironmentVariables:
        - Name: REACT_APP_API_URL
          Value: !Sub 'https://${RestApi}.execute-api.${AWS::Region}.amazonaws.com/${Environment}'
        - Name: REACT_APP_USER_POOL_ID
          Value: !Ref UserPool
        - Name: REACT_APP_USER_POOL_CLIENT_ID
          Value: !Ref UserPoolClient
        - Name: REACT_APP_REGION
          Value: !Ref AWS::Region
      Tags:
        - Key: Environment
          Value: !Ref Environment
        - Key: Application
          Value: GlobalInvoiceAI

  # ========================================
  # CLOUDWATCH DASHBOARD
  # ========================================

  CloudWatchDashboard:
    Type: AWS::CloudWatch::Dashboard
    Properties:
      DashboardName: !Sub '${AWS::StackName}-dashboard-${Environment}'
      DashboardBody: !Sub |
        {
          "widgets": [
            {
              "type": "metric",
              "x": 0,
              "y": 0,
              "width": 12,
              "height": 6,
              "properties": {
                "metrics": [
                  ["GlobalInvoiceAI", "InvoiceProcessed", "Environment", "${Environment}"],
                  [".", "ProcessingError", ".", "."]
                ],
                "view": "timeSeries",
                "stacked": false,
                "region": "${AWS::Region}",
                "title": "Invoice Processing Metrics",
                "period": 300
              }
            },
            {
              "type": "metric",
              "x": 12,
              "y": 0,
              "width": 12,
              "height": 6,
              "properties": {
                "metrics": [
                  ["AWS/Lambda", "Invocations", "FunctionName", "${InvoiceTriggerFunction}"],
                  [".", "Errors", ".", "."],
                  [".", "Duration", ".", "."]
                ],
                "view": "timeSeries",
                "stacked": false,
                "region": "${AWS::Region}",
                "title": "Lambda Function Metrics",
                "period": 300
              }
            },
            {
              "type": "log",
              "x": 0,
              "y": 6,
              "width": 24,
              "height": 6,
              "properties": {
                "query": "SOURCE '${InvoiceTriggerFunction}' | fields @timestamp, @message | sort @timestamp desc | limit 100",
                "region": "${AWS::Region}",
                "title": "Recent Processing Logs",
                "view": "table"
              }
            }
          ]
        }

  # ========================================
  # OUTPUTS
  # ========================================

Outputs:
  InvoiceUploadBucketName:
    Description: S3 bucket for uploading invoices
    Value: !Ref InvoiceUploadBucket
    Export:
      Name: !Sub '${AWS::StackName}-InvoiceUploadBucket-${Environment}'

  ProcessedInvoicesBucketName:
    Description: S3 bucket for processed invoices and PDFs
    Value: !Ref ProcessedInvoicesBucket
    Export:
      Name: !Sub '${AWS::StackName}-ProcessedInvoicesBucket-${Environment}'

  InvoicesTableName:
    Description: DynamoDB table for invoice records
    Value: !Ref InvoicesTable
    Export:
      Name: !Sub '${AWS::StackName}-InvoicesTable-${Environment}'

  UserPoolId:
    Description: Cognito User Pool ID
    Value: !Ref UserPool
    Export:
      Name: !Sub '${AWS::StackName}-UserPoolId-${Environment}'

  UserPoolClientId:
    Description: Cognito User Pool Client ID
    Value: !Ref UserPoolClient
    Export:
      Name: !Sub '${AWS::StackName}-UserPoolClientId-${Environment}'

  ApiGatewayUrl:
    Description: API Gateway endpoint URL
    Value: !Sub 'https://${RestApi}.execute-api.${AWS::Region}.amazonaws.com/${Environment}'
    Export:
      Name: !Sub '${AWS::StackName}-ApiGatewayUrl-${Environment}'

  AmplifyAppUrl:
    Description: Amplify application URL
    Value: !Sub 'https://${AmplifyApp.DefaultDomain}'
    Export:
      Name: !Sub '${AWS::StackName}-AmplifyAppUrl-${Environment}'

  CloudWatchDashboardUrl:
    Description: CloudWatch dashboard URL
    Value: !Sub 'https://${AWS::Region}.console.aws.amazon.com/cloudwatch/home?region=${AWS::Region}#dashboards:name=${CloudWatchDashboard}'
    Export:
      Name: !Sub '${AWS::StackName}-CloudWatchDashboardUrl-${Environment}'

  AgentCoreRuntimeArn:
    Description: AgentCore Runtime ARN (stored in Parameter Store)
    Value: !Sub '/globalinvoiceai/agentcore/runtime-arn'
    Export:
      Name: !Sub '${AWS::StackName}-AgentCoreRuntimeArn-${Environment}'
